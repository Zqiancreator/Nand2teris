# Jack Operating System

## Jack 语法

* Jack中无移位符
* 无法判断>=, <=, 
* 判断等于用=，而不是==
* 用~相当于C中的!

## Mathematical Operations

### 效率问题引例：

对于实现乘法，如n*m，本质上是对m加n-1次，时间复杂度为O(n), 但如果对m进行不断左移，再根据n的二进制位是否为1来做加法，则时间复杂度为$log_2n$，n每翻倍一次，时间复杂度只加一。

Math.jack 实现各种底层算术供用户使用

### multiply

* 由于Jack中没有移位操作，所以只能通过自加来实现左移，使用乘法会自动调用multiply函数，所以不能使用乘2来左移
* Jack中没法判断>=号，也就没法判断x>=mask，而且因为x可能第15位为1，没法用~反向判断，所以只能计算16次来判断结束
* 处理负数：所有数统一采用补码运算。
* 处理溢出：结果相当于对$2^{16}$取模，直接放弃高位溢出的数据

### divide

* 采用递归，让除数不断翻倍，判断新的除数与被除数的倍数关系
* 判断被除数是翻倍后的几倍，再判断是否需要加1
* 处理负数：用绝对值计算结果，最后加上符号
* 处理溢出：检查y的值，如果小于0，则发生溢出

### sqrt

* 只求开方的整数部分
* 不处理负数的开方，所以被开方数最大为$2^{15}$，那么开方结果的最高位次为$2^7$
* 从$2^7$开始往低位次逐位累加，直到处理到最低位次或平方结果为被开方数
* 处理溢出：判断`doub`的值是否小于零来检测溢出

## Memory Access

Memory.jack 分配RAM和堆内存，主要分配堆，堆中数据只做分配和把新释放的放在`freeList`末尾，按理操作系统还需要自动合并小的内存块，防止多次分配和释放后堆内存越来越碎片化而无法被好好利用。

### peek & poke

在内存RAM中某个地址取数据和读数据，由于Jack是弱类型语言，所以可以直接声名一个数组，然后把数组的地址设为从零开始，这样就能直接访问整块RAM，就直接通过地址作为下标来读写数据。

### alloc & deAlloc

最简单的做法就是分配时直接把新分配的堆的next设为null，等释放时也直接挂到末尾，缺点是如果要合并内存会更麻烦

更好点的做法是在回收时根据地址大小来把释放的空间放到合适的地址空间范围，并判断前者的起始地址加上长度后是否为后一个空间的起始地址，如果是，则说明前后空间连续，可以直接合并。但是这样每次释放时都得从`freeList`从头开始遍历，找到合适的位置放进去

## Graphics

Screen.jack 在屏幕上画图像，之前在RAM中映射了偏移量为16384的地址为对屏幕的像素的映射，对这里的数据写1就相当于把屏幕的对应点上色

具体映射如下图所示，屏幕上的每个点`(x, y)`相当于映射从地址16384开始的第`y*512 + x`位，16384每加一，相当于后移16位，因为$512/16 = 32$所以对应关系$32*y + x/16$的值为第几个十六进制数，再根据(x&15)来判断这个数的第几位要置一。

![image-20241003215226606](.\img\image-20241003215226606.png)

### drawPixel

根据上面的规则找到对应的address，再根据第二个参数对16取模的值来与这个地址的源值相或，以此保证写入这一位数据时不会改变其他位，因为Jack中没有取模操作，所以只能让数与15相与来达到相同效果。

### drawLine

根据$b/a$的值与$dy/dx$的比例关系来决定像素点是向右矫正还是向上矫正，如下图所示：

![image-20241003222843063](.\img\image-20241003222843063.png)

但是求b/a还是麻烦，可以用一个变量在每次矫正时加上dy或减去dx，最终通过判断这个变量的值的正负，相当于判断`a*dy - b*dx`表达式，相当于`dy/dx - b/a`的大小，就能知道下一步该往哪个方向矫正。

![image-20241004124619794](.\img\image-20241004124619794.png)

同时因为画线的方向有四个象限，所以需要判断`x1 x2 y1 y2`的大小来确定方向

### drawCircle

![image-20241004135456070](.\img\image-20241004135456070.png)

一条一条水平线画满整个圆

## Handling Textual Output

Output.jack 打印字符，根据位图把相应位字符变黑

![image-20241004152055928](.\img\image-20241004152055928.png)  do Output.create(97,0,0,0,14,24,30,27,27,54,0,0);      // a

题目已经定义好了字体中各个字符的样式，只需要根据样式在create中填充相应的位即可，比如这个的a前三行为空，就是全0，第四行为01110000，反过来00001110=14，所以填入14即可

### printChar

根据前面Graphics中的计算，对于一个坐标`(x, y)`来说，$32*y + x/16$的值为第几个十六进制数，再根据(x&15)来判断这个数的第几位要置一。这里可以看到每个字符的位图大小为`11*8`，所以新的`address = 32*y*11 + x/2`，因为对于每个字符的位图都有11行，所以要把这个字符的map遍历11次找到所有的位，每换一行`address += 32`

### printInt

对于整型需要转换成字符串再打印

## Input

Keyboard.jack RAM[24576]用于记录键盘输入的字符的ascall码值，通过这个数来检测键盘的输入

### keyPressed

用于获取当时这一刻键盘按下的字符

### readChar

用于获取用户按下的一个字符，检测他按下并松开的这一过程，所以需要用两个循环检测按下和松开

### readLine

把传入的字符串打印到屏幕上，并允许用户再输入新的字符，把新的字符添加到后面，直到用户输入了回车才结束，并把新的字符串返回

### readInt

直接调用`readLine`，把结果转换成`int`

## String Processing

String.jack 提供字符串的API method是字符串对象调用的函数 function是字符串类拥有的函数 field修饰的变量属于对象所拥有

对于method如果要返回这个对象，用this

### intValue

数字的ascall码范围位48-57 `'-'`号的ascall码值为45

### setInt

先按照低位到高位的顺序存到一个暂时的String对象中，再把这个String对象中的字符按序取出压入目的对象中，由于Jack中没有取模操作，所以只能通过`val - val/10*10`来获取低位

最后把暂时的String对象给释放

## Sys Class

操作系统执行的第一个类，电脑启动时在内存顶部放上两行代码，第一行设置SP指针，第二行即调用Sys.init()函数，当然这两行代码是机器语言代码，现在编译器都还没启动，在Sys.init中会调用Jack中的Main.main()，从这里开始，整个系统启动

init中调用各个类的init函数进行初始化

### wait

相当于sleep，这里直接用循环等待，设置一个值每次循环一次减一来达到等待相应的时间，具体值随CPU能力改变

## 测试：

先使用JackCompiler编译Jack语言为.vm

```
..\..\tools\JackCompiler.bat Math.jack
```

然后在Test文件夹下把Main.jack编译成.vm

```
..\..\tools\JackCompiler.bat Math.jack
```

再在tools中打开VMEmulator，加载对应的.`tst`